# 罕见编程问题与底层技术探索

## 一、编程语言底层机制类

### 1. Java中`invokedynamic`指令的动态绑定机制
#### 问题
在Java中，`invokedynamic`指令如何实现动态语言特性？它与`invokevirtual`的性能差异在哪些场景下会显著体现？

#### 关键点
- 涉及JVM字节码指令集的动态绑定机制
- 需理解Lambda表达式、方法句柄（MethodHandle）与`invokedynamic`的联动逻辑
- 常规资料多停留在应用层面，缺乏底层实现细节

### 2. C语言中`volatile`关键字的CPU架构差异
#### 问题
C语言中`volatile`关键字能否禁止CPU缓存？在ARM架构与x86架构下的实现有何差异？

#### 关键点
- 涉及内存屏障（Memory Barrier）与CPU架构的交互
- 需结合具体指令集（如ARM的`dmb`/`dse`指令）分析
- 常见资料仅说明"防止编译器优化"，未深入硬件层面

### 3. Python GIL与多核CPU利用率的异常现象
#### 问题
Python的GIL（全局解释器锁）在多核CPU上执行纯计算任务时，为何有时CPU利用率仍能超过100%？

#### 关键点
- 涉及操作系统进程调度、Python解释器的线程切换时机（`Py_TICK_THRESHOLD`）
- 需分析CPython的源码实现，而非仅停留在GIL的常规解释

### 4. JavaScript引擎对`for (let i=0)`的编译优化
#### 问题
JavaScript引擎（如V8）在编译`for (let i=0; i<10; i++)`时，会对`i`做哪些优化？为何改用`const i`可能提升性能？

#### 关键点
- 涉及JIT编译器（如TurboFan）的逃逸分析（Escape Analysis）
- 需参考V8源码或官方技术文档中的寄存器分配策略

### 5. Go语言调度器的"烫手山芋"场景处理
#### 问题
Go语言的调度器（Goroutine Scheduler）在遇到"烫手山芋"（Hot Potato）调度场景时，如何避免栈溢出？

#### 关键点
- 涉及M:N调度模型中的工作窃取（Work Stealing）机制
- 需理解Go runtime的`gopark`/`goready`底层函数与栈增长策略

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